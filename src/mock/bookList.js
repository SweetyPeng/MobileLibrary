module.exports = 
  {
    "count": 20,
    "start": 0,
    "total": 1141594,
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 404,
          "average": "8.8",
          "min": 0
        },
        "subtitle": "使用muduo C++网络库",
        "author": [
          "陈硕"
        ],
        "pubdate": "2013-1-15",
        "tags": [
          {
            "count": 561,
            "name": "网络编程",
            "title": "网络编程"
          },
          {
            "count": 501,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 496,
            "name": "Linux",
            "title": "Linux"
          },
          {
            "count": 418,
            "name": "多线程",
            "title": "多线程"
          },
          {
            "count": 138,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 133,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 77,
            "name": "Networks",
            "title": "Networks"
          },
          {
            "count": 75,
            "name": "Programming",
            "title": "Programming"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599",
        "pages": "610",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/20471211\/",
        "id": "20471211",
        "publisher": "电子工业出版社",
        "isbn10": "7121192829",
        "isbn13": "9787121192821",
        "title": "Linux多线程服务端编程",
        "url": "https:\/\/api.douban.com\/v2\/book\/20471211",
        "alt_title": "",
        "author_intro": "陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。",
        "summary": "本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。",
        "price": "89.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 168,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "C++语言版 第三版",
        "author": [
          "邓俊辉"
        ],
        "pubdate": "2013-9",
        "tags": [
          {
            "count": 193,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 118,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 94,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 83,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 82,
            "name": "数据结构与算法",
            "title": "数据结构与算法"
          },
          {
            "count": 60,
            "name": "邓俊辉",
            "title": "邓俊辉"
          },
          {
            "count": 42,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 27,
            "name": "algorithm",
            "title": "algorithm"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28388499.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章 绪论\n1.1 计算机与算法\n1.2 复杂度度量\n1.3 复杂度分析\n1.4*递归\n1.5 抽象数据类型\n第2章 向量\n2.1 从数组到向量\n2.2 接口\n2.3 构造与析构\n2.4 动态空间管理\n2.5 常规向量\n2.6 有序向量\n2.7*排序与下界\n2.8 排序器\n第3章 列表\n3.1 从向量到列表\n3.2 接口\n3.3 列表\n3.4 有序列表\n3.5 排序器\n第4章 栈与队列\n4.1 栈\n4.2 栈与递归\n4.3 栈的典型应用\n4.4*试探回溯法\n4.5 队列\n4.6 队列应用\n第5章 二叉树\n5.1 二叉树及其表示\n5.2 编码树\n5.3 二叉树的实现\n5.4 遍历\n5.5 Huffmann 编码\n第6章 图\n6.1 概述\n6.2 抽象数据类型\n6.3 邻接矩阵\n6.4 邻接表\n6.5 图遍历算法概述\n6.6 广度优先搜索\n6.7 深度优先搜索\n6.8 拓扑排序\n6.9*双连通域分解\n6.10 优先级搜索\n6.11 最小支撑树\n6.12 最短路径\n第7章 搜索树\n7.1 查找\n7.2 二叉搜索树\n7.3 平衡二叉搜索树\n7.4 AVL 树\n第8章 高级搜索树 高级搜索树\n8.1 伸展树\n8.2 B—树\n8.3*红黑树\n8.4*kd—树\n第9章 词典\n9.1 词典 ADTADTADT\n9.2*跳转表\n9.3 散列表\n9.4*散列应用\n第10章 优先级队列\n10.1 优先级队列 ADT\n10.2 堆\n10.3*左式堆\n第11章 串\n11.1 串及匹配\n11.2 蛮力算法\n11.3 KMP算法\n11.4*BM 算法\n11.5*Karp—Rabin算法\n第12章 排序\n12.1 快速排序\n12.2*选取与中位数\n12.3*希尔排序\n附录\n参考文献\n插图索引\n表格索引\n算法索引\n代码索引\n关键词索引",
        "pages": "389",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s28388499.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s28388499.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28388499.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/25859528\/",
        "id": "25859528",
        "publisher": "清华大学出版社",
        "isbn10": "7302330646",
        "isbn13": "9787302330646",
        "title": "数据结构",
        "url": "https:\/\/api.douban.com\/v2\/book\/25859528",
        "alt_title": "",
        "author_intro": "邓俊辉，清华大学计算机系副教授。1993年、1997年分别于清华大学计算机系获工学学士和工学博士学位。主要研究方向为科学计算可视化、计算几何及计算机图形学。长期承担清华大学计算机本科生专业基础课程“数据结构”和研究生基础理论课“计算几何”的教学工作，编著的《数据结构与算法（Java描述）》入选“北京市高等教育精品教材”，参与编著的《数据结构（用面向对象方法与C++语言描述）》入选“国家级高等教育精品教材”，曾获清华大学“青年教师教学优秀奖”、清华大学“教书育人奖”、清华大学“教学成果奖”二等奖、清华大学“教学成果奖”一等奖、中国高校科学技术奖二等奖、宝钢教育基金“宝钢教育奖”。",
        "summary": "《清华大学计算机系列教材:数据结构(C++语言版)(第3版)》按照面向对象程序设计的思想，根据作者多年的教学积累，系统地介绍各类数据结构的功能、表示和实现，对比各类数据结构适用的应用环境；结合实际问题展示算法设计的一般性模式与方法、算法实现的主流技巧，以及算法效率的评判依据和分析方法；以高度概括的体例为线索贯穿全书，并通过对比和类比揭示数据结构与算法的内在联系，帮助读者形成整体性认识。",
        "series": {
          "id": "13234",
          "title": "清华大学计算机系列教材"
        },
        "price": "39.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1692,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "C语言描述",
        "author": [
          "维斯"
        ],
        "pubdate": "2004-1-1",
        "tags": [
          {
            "count": 2105,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 1651,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 883,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 798,
            "name": "数据结构与算法分析",
            "title": "数据结构与算法分析"
          },
          {
            "count": 689,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 631,
            "name": "算法、数据结构",
            "title": "算法、数据结构"
          },
          {
            "count": 599,
            "name": "C",
            "title": "C"
          },
          {
            "count": 485,
            "name": "C语言",
            "title": "C语言"
          }
        ],
        "origin_title": "Data Structures and Algorithm Analysis in C:Second Edition",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg",
        "binding": "平装",
        "translator": [
          "冯舜玺"
        ],
        "catalog": "第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引",
        "pages": "391",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1139426\/",
        "id": "1139426",
        "publisher": "机械工业出版社",
        "isbn10": "711112748X",
        "isbn13": "9787111127482",
        "title": "数据结构与算法分析",
        "url": "https:\/\/api.douban.com\/v2\/book\/1139426",
        "alt_title": "Data Structures and Algorithm Analysis in C:Second Edition",
        "author_intro": "Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。",
        "summary": "本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。",
        "series": {
          "id": "1163",
          "title": "计算机科学丛书"
        },
        "price": "35.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 210,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "42 Specific Ways to Improve Your Use of C++11 and C++14",
        "author": [
          "Scott Meyers"
        ],
        "pubdate": "2014-12",
        "tags": [
          {
            "count": 283,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 134,
            "name": "C++11",
            "title": "C++11"
          },
          {
            "count": 88,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 70,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 66,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 63,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 36,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 27,
            "name": "effective",
            "title": "effective"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg",
        "binding": "Paperback",
        "translator": [],
        "catalog": "",
        "pages": "320",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/25923597\/",
        "id": "25923597",
        "publisher": "O'Reilly Media",
        "isbn10": "1491903996",
        "isbn13": "9781491903995",
        "title": "Effective Modern C++",
        "url": "https:\/\/api.douban.com\/v2\/book\/25923597",
        "alt_title": "",
        "author_intro": "Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.",
        "summary": "Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14",
        "price": "USD 49.99"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 276,
          "average": "8.5",
          "min": 0
        },
        "subtitle": "C++描述(第三版)",
        "author": [
          "[美]Mark Allen Weiss"
        ],
        "pubdate": "2007年",
        "tags": [
          {
            "count": 261,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 192,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 186,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 97,
            "name": "数据结构与算法",
            "title": "数据结构与算法"
          },
          {
            "count": 89,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 54,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 42,
            "name": "算法分析",
            "title": "算法分析"
          },
          {
            "count": 36,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s2210957.jpg",
        "binding": "",
        "translator": [
          "张怀勇"
        ],
        "catalog": "",
        "pages": "435",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s2210957.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s2210957.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s2210957.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1971825\/",
        "id": "1971825",
        "publisher": "人民邮电出版社",
        "isbn10": "7115139237",
        "isbn13": "9787115139238",
        "title": "数据结构与算法分析",
        "url": "https:\/\/api.douban.com\/v2\/book\/1971825",
        "alt_title": "Data Structures and Algorithm Analysis in C++",
        "author_intro": "Mark Allen Weiss\n1987年在普林斯顿大学获得计算机科学博士学位,师从著名算法大师Robert Sedgewick,现任美国佛罗里达国际大学计算与信息科学学院教授.他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004).他的主要研究方向是数据结构,算法,和教育学.",
        "summary": "《数据结构与算法分析:C++描述(第3版)》是数据结构和算法分析的经典教材，书中使用主流的程序设计语言C++作为具体的实现语言。书的内容包括表、栈、队列、树、散列表、优先队列、排序、不相交集算法、图论算法、算法分析、算法设计、摊还分析、查找树算法、k-d树和配对堆等。《数据结构与算法分析:C++描述(第3版)》适合作为计算机相关专业本科生的数据结构课程和研究生算法分析课程的教材。本科生的数据结构课程可以使用《数据结构与算法分析:C++描述(第3版)》第1章～第9章，多学时课程还可以讲解第10章；研究生算法分析课程可以使用第6章～第12章。",
        "series": {
          "id": "18507",
          "title": "图灵计算机科学丛书"
        },
        "price": "49.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 514,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "使用Visual C++5.0 & MFC 4.2",
        "author": [
          "侯俊杰"
        ],
        "pubdate": "2001-1",
        "tags": [
          {
            "count": 294,
            "name": "MFC",
            "title": "MFC"
          },
          {
            "count": 167,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 101,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 91,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 71,
            "name": "深入浅出MFC",
            "title": "深入浅出MFC"
          },
          {
            "count": 70,
            "name": "侯捷",
            "title": "侯捷"
          },
          {
            "count": 61,
            "name": "Windows",
            "title": "Windows"
          },
          {
            "count": 38,
            "name": "经典",
            "title": "经典"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg",
        "binding": "平装16开",
        "translator": [],
        "catalog": "第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录",
        "pages": "701",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1094852\/",
        "id": "1094852",
        "publisher": "华中科技大学出版社",
        "isbn10": "7900614931",
        "isbn13": "9787900614933",
        "title": "深入浅出MFC （第二版）",
        "url": "https:\/\/api.douban.com\/v2\/book\/1094852",
        "alt_title": "",
        "author_intro": "侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”",
        "summary": "《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。",
        "price": "80.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1271,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Stanley B. Lippman",
          "[美] Josée Lajoie",
          "[美] Barbara E. Moo"
        ],
        "pubdate": "2013-9-1",
        "tags": [
          {
            "count": 1403,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 618,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 507,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 414,
            "name": "C++11",
            "title": "C++11"
          },
          {
            "count": 375,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 373,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 329,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 291,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "C++ Primer, 5th Edition",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s27023182.jpg",
        "binding": "平装",
        "translator": [
          "王刚",
          "杨巨峰"
        ],
        "catalog": "第1章  开始\t1\n1.1  编写一个简单的C++程序\t2\n1.1.1  编译、运行程序\t3\n1.2  初识输入输出\t5\n1.3  注释简介\t8\n1.4  控制流\t10\n1.4.1  while语句\t10\n1.4.2  for语句\t11\n1.4.3  读取数量不定的输入数据\t13\n1.4.4  if语句\t15\n1.5  类简介\t17\n1.5.1  Sales_item类\t17\n1.5.2  初识成员函数\t20\n1.6  书店程序\t21\n小结\t23\n术语表\t23\n第Ⅰ部分  C++基础\t27\n第2章  变量和基本类型\t29\n2.1  基本内置类型\t30\n2.1.1  算术类型\t30\n2.1.2  类型转换\t32\n2.1.3  字面值常量\t35\n2.2  变量\t38\n2.2.1  变量定义\t38\n2.2.2  变量声明和定义的关系\t41\n2.2.3  标识符\t42\n2.2.4  名字的作用域\t43\n2.3  复合类型\t45\n2.3.1  引用\t45\n2.3.2  指针\t47\n2.3.3  理解复合类型的声明\t51\n2.4  const限定符\t53\n2.4.1  const的引用\t54\n2.4.2  指针和const\t56\n2.4.3  顶层const\t57\n2.4.4  constexpr和常量表达式\t58\n2.5  处理类型\t60\n2.5.1  类型别名\t60\n2.5.2  auto类型说明符\t61\n2.5.3  decltype类型指示符\t62\n2.6  自定义数据结构\t64\n2.6.1  定义Sales_data类型\t64\n2.6.2  使用Sales_data类\t66\n2.6.3  编写自己的头文件\t67\n小结\t69\n术语表\t69\n第3章  字符串、向量和数组\t73\n3.1  命名空间的using声明\t74\n3.2  标准库类型string\t75\n3.2.1  定义和初始化string对象\t76\n3.2.2  string对象上的操作\t77\n3.2.3  处理string对象中的字符\t81\n3.3  标准库类型vector\t86\n3.3.1  定义和初始化vector对象\t87\n3.3.2  向vector对象中添加元素\t90\n3.3.3  其他vector操作\t91\n3.4  迭代器介绍\t95\n3.4.1  使用迭代器\t95\n3.4.2  迭代器运算\t99\n3.5  数组\t101\n3.5.1  定义和初始化内置数组\t101\n3.5.2  访问数组元素\t103\n3.5.3  指针和数组\t105\n3.5.4  C风格字符串\t109\n3.5.5  与旧代码的接口\t111\n3.6  多维数组\t112\n小结\t117\n术语表\t117\n第4章  表达式\t119\n4.1  基础\t120\n4.1.1  基本概念\t120\n4.1.2  优先级与结合律\t121\n4.1.3  求值顺序\t123\n4.2  算术运算符\t124\n4.3  逻辑和关系运算符\t126\n4.4  赋值运算符\t129\n4.5  递增和递减运算符\t131\n4.6  成员访问运算符\t133\n4.7  条件运算符\t134\n4.8  位运算符\t135\n4.9  sizeof运算符\t139\n4.10  逗号运算符\t140\n4.11  类型转换\t141\n4.11.1  算术转换\t142\n4.11.2  其他隐式类型转换\t143\n4.11.3  显式转换\t144\n4.12  运算符优先级表\t147\n小结\t149\n术语表\t149\n第5章  语句\t153\n5.1  简单语句\t154\n5.2  语句作用域\t155\n5.3  条件语句\t156\n5.3.1  if语句\t156\n5.3.2  switch语句\t159\n5.4  迭代语句\t165\n5.4.1  while语句\t165\n5.4.2  传统的for语句\t166\n5.4.3  范围for语句\t168\n5.4.4  do while语句\t169\n5.5  跳转语句\t170\n5.5.1  break语句\t170\n5.5.2  continue语句\t171\n5.5.3  goto语句\t172\n5.6  TRY语句块和异常处理\t172\n5.6.1  throw表达式\t173\n5.6.2  try语句块\t174\n5.6.3  标准异常\t176\n小结\t178\n术语表\t178\n第6章  函数\t181\n6.1  函数基础\t182\n6.1.1  局部对象\t184\n6.1.2  函数声明\t186\n6.1.3  分离式编译\t186\n6.2  参数传递\t187\n6.2.1  传值参数\t187\n6.2.2  传引用参数\t188\n6.2.3  const形参和实参\t190\n6.2.4  数组形参\t193\n6.2.5  main：处理命令行选项\t196\n6.2.6  含有可变形参的函数\t197\n6.3  返回类型和return语句\t199\n6.3.1  无返回值函数\t200\n6.3.2  有返回值函数\t200\n6.3.3  返回数组指针\t205\n6.4  函数重载\t206\n6.4.1  重载与作用域\t210\n6.5  特殊用途语言特性\t211\n6.5.1  默认实参\t211\n6.5.2  内联函数和constexpr函数\t213\n6.5.3  调试帮助\t215\n6.6  函数匹配\t217\n6.6.1  实参类型转换\t219\n6.7  函数指针\t221\n小结\t225\n术语表\t225\n第7章  类\t227\n7.1  定义抽象数据类型\t228\n7.1.1  设计Sales_data类\t228\n7.1.2  定义改进的Sales_data类\t230\n7.1.3  定义类相关的非成员函数\t234\n7.1.4  构造函数\t235\n7.1.5  拷贝、赋值和析构\t239\n7.2  访问控制与封装\t240\n7.2.1  友元\t241\n7.3  类的其他特性\t243\n7.3.1  类成员再探\t243\n7.3.2  返回*this的成员函数\t246\n7.3.3  类类型\t249\n7.3.4  友元再探\t250\n7.4  类的作用域\t253\n7.4.1  名字查找与类的作用域\t254\n7.5  构造函数再探\t257\n7.5.1  构造函数初始值列表\t258\n7.5.2  委托构造函数\t261\n7.5.3  默认构造函数的作用\t262\n7.5.4  隐式的类类型转换\t263\n7.5.5  聚合类\t266\n7.5.6  字面值常量类\t267\n7.6  类的静态成员\t268\n小结\t273\n术语表\t273\n第Ⅱ部  C++标准库\t275\n第8章  IO库\t277\n8.1  IO类\t278\n8.1.1  IO对象无拷贝或赋值\t279\n8.1.2  条件状态\t279\n8.1.3  管理输出缓冲\t281\n8.2  文件输入输出\t283\n8.2.1  使用文件流对象\t284\n8.2.2  文件模式\t286\n8.3  string流\t287\n8.3.1  使用istringstream\t287\n8.3.2  使用ostringstream\t289\n小结\t290\n术语表\t290\n第9章  顺序容器\t291\n9.1  顺序容器概述\t292\n9.2  容器库概览\t294\n9.2.1  迭代器\t296\n9.2.2  容器类型成员\t297\n9.2.3  begin和end成员\t298\n9.2.4  容器定义和初始化\t299\n9.2.5  赋值和swap\t302\n9.2.6  容器大小操作\t304\n9.2.7  关系运算符\t304\n9.3  顺序容器操作\t305\n9.3.1  向顺序容器添加元素\t305\n9.3.2  访问元素\t309\n9.3.3  删除元素\t311\n9.3.4  特殊的forward_list操作\t312\n9.3.5  改变容器大小\t314\n9.3.6  容器操作可能使迭代器失效\t315\n9.4  vector对象是如何增长的\t317\n9.5  额外的string操作\t320\n9.5.1  构造string的其他方法\t321\n9.5.2  改变string的其他方法\t322\n9.5.3  string搜索操作\t325\n9.5.4  compare函数\t327\n9.5.5  数值转换\t327\n9.6  容器适配器\t329\n小结\t332\n术语表\t332\n第10章  泛型算法\t335\n10.1  概述\t336\n10.2  初识泛型算法\t338\n10.2.1  只读算法\t338\n10.2.2  写容器元素的算法\t339\n10.2.3  重排容器元素的算法\t342\n10.3  定制操作\t344\n10.3.1  向算法传递函数\t344\n10.3.2  lambda表达式\t345\n10.3.3  lambda捕获和返回\t349\n10.3.4  参数绑定\t354\n10.4  再探迭代器\t357\n10.4.1  插入迭代器\t358\n10.4.2  iostream迭代器\t359\n10.4.3  反向迭代器\t363\n10.5  泛型算法结构\t365\n10.5.1  5类迭代器\t365\n10.5.2  算法形参模式\t367\n10.5.3  算法命名规范\t368\n10.6  特定容器算法\t369\n小结\t371\n术语表\t371\n第11章  关联容器\t373\n11.1  使用关联容器\t374\n11.2  关联容器概述\t376\n11.2.1  定义关联容器\t376\n11.2.2  关键字类型的要求\t378\n11.2.3  pair类型\t379\n11.3  关联容器操作\t381\n11.3.1  关联容器迭代器\t382\n11.3.2  添加元素\t383\n11.3.3  删除元素\t386\n11.3.4  map的下标操作\t387\n11.3.5  访问元素\t388\n11.3.6  一个单词转换的map\t391\n11.4  无序容器\t394\n小结\t397\n术语表\t397\n第12章  动态内存\t399\n12.1  动态内存与智能指针\t400\n12.1.1  shared_ptr类\t400\n12.1.2  直接管理内存\t407\n12.1.3  shared_ptr和new结合使用\t412\n12.1.4  智能指针和异常\t415\n12.1.5  unique_ptr\t417\n12.1.6  weak_ptr\t420\n12.2  动态数组\t423\n12.2.1  new和数组\t423\n12.2.2  allocator类\t427\n12.3  使用标准库：文本查询程序\t430\n12.3.1  文本查询程序设计\t430\n12.3.2  文本查询程序类的定义\t432\n小结\t436\n术语表\t436\n第Ⅲ部分  类设计者的工具\t437\n第13章  拷贝控制\t439\n13.1  拷贝、赋值与销毁\t440\n13.1.1  拷贝构造函数\t440\n13.1.2  拷贝赋值运算符\t443\n13.1.3  析构函数\t444\n13.1.4  三\/五法则\t447\n13.1.5  使用=default\t449\n13.1.6  阻止拷贝\t449\n13.2  拷贝控制和资源管理\t452\n13.2.1  行为像值的类\t453\n13.2.2  定义行为像指针的类\t455\n13.3  交换操作\t457\n13.4  拷贝控制示例\t460\n13.5  动态内存管理类\t464\n13.6  对象移动\t470\n13.6.1  右值引用\t471\n13.6.2  移动构造函数和移动赋值运算符\t473\n13.6.3  右值引用和成员函数\t481\n小结\t486\n术语表\t486\n第14章  操作重载与类型转换\t489\n14.1  基本概念\t490\n14.2  输入和输出运算符\t494\n14.2.1  重载输出运算符<<\t494\n14.2.2  重载输入运算符>>\t495\n14.3  算术和关系运算符\t497\n14.3.1  相等运算符\t497\n14.3.2  关系运算符\t498\n14.4  赋值运算符\t499\n14.5  下标运算符\t501\n14.6  递增和递减运算符\t502\n14.7  成员访问运算符\t504\n14.8  函数调用运算符\t506\n14.8.1  lambda是函数对象\t507\n14.8.2  标准库定义的函数对象\t509\n14.8.3  可调用对象与function\t511\n14.9  重载、类型转换与运算符\t514\n14.9.1  类型转换运算符\t514\n14.9.2  避免有二义性的类型转换\t517\n14.9.3  函数匹配与重载运算符\t521\n小结\t523\n术语表\t523\n第15章  面向对象程序设计\t525\n15.1  OOP：概述\t526\n15.2  定义基类和派生类\t527\n15.2.1  定义基类\t528\n15.2.2  定义派生类\t529\n15.2.3  类型转换与继承\t534\n15.3  虚函数\t536\n15.4  抽象基类\t540\n15.5  访问控制与继承\t542\n15.6  继承中的类作用域\t547\n15.7  构造函数与拷贝控制\t551\n15.7.1  虚析构函数\t552\n15.7.2  合成拷贝控制与继承\t552\n15.7.3  派生类的拷贝控制成员\t554\n15.7.4  继承的构造函数\t557\n15.8  容器与继承\t558\n15.8.1  编写Basket类\t559\n15.9  文本查询程序再探\t562\n15.9.1  面向对象的解决方案\t563\n15.9.2  Query_base类和Query类\t567\n15.9.3  派生类\t568\n15.9.4  eval函数\t571\n小结\t575\n术语表\t575\n第16章  模板与泛型编程\t577\n16.1  定义模板\t578\n16.1.1  函数模板\t578\n16.1.2  类模板\t583\n16.1.3  模板参数\t592\n16.1.4  成员模板\t595\n16.1.5  控制实例化\t597\n16.1.6  效率与灵活性\t599\n16.2  模板实参推断\t600\n16.2.1  类型转换与模板类型参数\t601\n16.2.2  函数模板显式实参\t603\n16.2.3  尾置返回类型与类型转换\t604\n16.2.4  函数指针和实参推断\t607\n16.2.5  模板实参推断和引用\t608\n16.2.6  理解std::move\t610\n16.2.7  转发\t612\n16.3  重载与模板\t614\n16.4  可变参数模板\t618\n16.4.1  编写可变参数函数模板\t620\n16.4.2  包扩展\t621\n16.4.3  转发参数包\t622\n16.5  模板特例化\t624\n小结\t630\n术语表\t630\n第Ⅳ部分  高级主题\t633\n第17章  标准库特殊设施\t635\n17.1  tuple类型\t636\n17.1.1  定义和初始化tuple\t637\n17.1.2  使用tuple返回多个值\t638\n17.2  BITSET类型\t640\n17.2.1  定义和初始化bitset\t641\n17.2.2  bitset操作\t643\n17.3  正则表达式\t645\n17.3.1  使用正则表达式库\t646\n17.3.2  匹配与Regex迭代器类型\t650\n17.3.3  使用子表达式\t653\n17.3.4  使用regex_replace\t657\n17.4  随机数\t659\n17.4.2  其他随机数分布\t663\nbernoulli_distribution类\t665\n17.5  IO库再探\t666\n17.5.1  格式化输入与输出\t666\n17.5.2  未格式化的输入\/输出操作\t673\n17.5.3  流随机访问\t676\n小结\t680\n术语表\t680\n第18章  用于大型程序的工具\t683\n18.1  异常处理\t684\n18.1.1  抛出异常\t684\n18.1.2  捕获异常\t687\n18.1.3  函数try语句块与构造函数\t689\n18.1.4  noexcept异常说明\t690\n18.1.5  异常类层次\t693\n18.2  命名空间\t695\n18.2.1  命名空间定义\t695\n18.2.2  使用命名空间成员\t701\n18.2.3  类、命名空间与作用域\t705\n18.2.4  重载与命名空间\t708\n18.3  多重继承与虚继承\t710\n18.3.1  多重继承\t711\n18.3.2  类型转换与多个基类\t713\n18.3.3  多重继承下的类作用域\t715\n18.3.4  虚继承\t717\n18.3.5  构造函数与虚继承\t720\n小结\t722\n术语表\t722\n第19章  特殊工具与技术\t725\n19.1  控制内存分配\t726\n19.1.1  重载new和delete\t726\n19.1.2  定位new表达式\t729\n19.2  运行时类型识别\t730\n19.2.1  dynamic_cast运算符\t730\n19.2.2  typeid运算符\t732\n19.2.3  使用RTTI\t733\n19.2.4  type_info类\t735\n19.3  枚举类型\t736\n19.4  类成员指针\t739\n19.4.1  数据成员指针\t740\n19.4.2  成员函数指针\t741\n19.4.3  将成员函数用作可调用对象\t744\n19.5  嵌套类\t746\n19.6  union：一种节省空间的类\t749\n19.7  局部类\t754\n19.8  固有的不可移植的特性\t755\n19.8.1  位域\t756\n19.8.2  volatile限定符\t757\n19.8.3  链接指示：extern \"C\"\t758\n小结\t762\n术语表\t762\n附录A  标准库\t765\nA.1  标准库名字和头文件\t766\nA.2  算法概览\t770\nA.2.1  查找对象的算法\t771\nA.2.2  其他只读算法\t772\nA.2.3  二分搜索算法\t772\nA.2.4  写容器元素的算法\t773\nA.2.5  划分与排序算法\t775\nA.2.6  通用重排操作\t776\nA.2.7  排列算法\t778\nA.2.8  有序序列的集合算法\t778\nA.2.9  最小值和最大值\t779\nA.2.10  数值算法\t780\nA.3  随机数\t781\nA.3.1  随机数分布\t781\nA.3.2  随机数引擎\t783\nC++11的新特性\n2.1.1  long long类型\t31\n2.2.1  列表初始化\t39\n2.3.2  nullptr常量\t48\n2.4.4  constexpr变量\t59\n2.5.1  类型别名声明\t60\n2.5.2  auto类型指示符\t61\n2.5.3  decltype类型指示符\t62\n2.6.1  类内初始化\t65\n3.2.2  使用auto或decltype缩写类型\t79\n3.2.3  范围for语句\t82\n3.3   定义vector对象的vector（向量的向量）\t87\n3.3.1  vector对象的列表初始化\t88\n3.4.1  容器的cbegin和cend函数\t98\n3.5.3  标准库begin和end函数\t106\n3.6   使用auto和decltype简化声明\t115\n4.2   除法的舍入规则\t125\n4.4   用大括号包围的值列表赋值\t129\n4.9   将sizeof用于类成员\t139\n5.4.3 范围for语句\t168\n6.2.6  标准库initializer_list类\t197\n6.3.2  列表初始化返回值\t203\n6.3.3  定义尾置返回类型\t206\n6.3.3  使用decltype简化返回类型定义\n6.5.2  constexpr函数\t214\n7.1.4  使用=default生成默认构造函数\t237\n7.3.1  类对象成员的类内初始化\t246\n7.5.2  委托构造函数\t261\n7.5.6  constexpr构造函数\t268\n8.2.1  用string对象处理文件名\t284\n9.1   array和forward_list容器\t293\n9.2.3 容器的cbegin和cend函数\t298\n9.2.4  容器的列表初始化\t300\n9.2.5  容器的非成员函数swap\t303\n9.3.1  容器insert成员的返回类型\t308\n9.3.1  容器的emplace成员的返回类型\t308\n9.4   shrink_to_fit\t318\n9.5.5  string的数值转换函数\t327\n10.3.2  Lambda表达式\t346\n10.3.3  Lambda表达式中的尾置返回类型\t353\n10.3.4  标准库bind函数\t354\n11.2.1  关联容器的列表初始化\t377\n11.2.3  列表初始化pair的返回类型\t380\n11.3.2  pair的列表初始化\t384\n11.4   无序容器\t394\n12.1   智能指针\t400\n12.1.1  shared_ptr类\n12.1.2  动态分配对象的列表初始化\t407\n12.1.2  auto和动态分配\t408\n12.1.5  unique_ptr类\t417\n12.1.6  weak_ptr类\t420\n12.2.1  范围for语句不能应用于动态分配数组\t424\n12.2.1  动态分配数组的列表初始化\t424\n12.2.1  auto不能用于分配数组\t424\n12.2.2  allocator::construct可使用任意构造函数\t428\n13.1.5  将=default用于拷贝控制成员\t449\n13.1.6  使用=default阻止拷贝类对象\t449\n13.5   用移动类对象代替拷贝类对象\t469\n13.6.1  右值引用\t471\n13.6.1  标准库move函数\t472\n13.6.2  移动构造函数和移动赋值\t473\n13.6.2  移动构造函数通常应该是noexcept\t473\n13.6.2  移动迭代器\t480\n13.6.3  引用限定成员函数\t483\n14.8.3  function类模板\t512\n14.9.1  explicit类型转换运算符\t516\n15.2.2  虚函数的override指示符\t530\n15.2.2  通过定义类为final来阻止继承\t533\n15.3   虚函数的override和final指示符\t538\n15.7.2  删除的拷贝控制和继承\t553\n15.7.4  继承的构造函数\t557\n16.1.2  声明模板类型形参为友元\t590\n16.1.2  模板类型别名\t590\n16.1.3  模板函数的默认模板参数\t594\n16.1.5  实例化的显式控制\t597\n16.2.3  模板函数与尾置返回类型\t605\n16.2.5  引用折叠规则\t609\n16.2.6  用static_cast将左值转换为右值\t612\n16.2.7  标准库forward函数\t614\n16.4   可变参数模板\t618\n16.4   sizeof...运算符\t619\n16.4.3  可变参数模板与转发\t622\n17.1   标准库Tuple类模板\t636\n17.2.2  新的bitset运算\t643\n17.3   正则表达式库\t645\n17.4   随机数库\t659\n17.5.1  浮点数格式控制\t670\n18.1.4  noexcept异常指示符\t690\n18.1.4  noexcept运算符\t691\n18.2.1  内联名字空间\t699\n18.3.1  继承的构造函数和多重继承\t712\n19.3   有作用域的enum\t736\n19.3   说明类型用于保存enum对象\t738\n19.3   enum的提前声明\t738\n19.4.3  标准库mem_fn类模板\t746\n19.6   类类型的联合成员\t751",
        "pages": "838",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s27023182.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s27023182.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s27023182.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/25708312\/",
        "id": "25708312",
        "publisher": "电子工业出版社",
        "isbn10": "7121155354",
        "isbn13": "9787121155352",
        "title": "C++ Primer 中文版（第 5 版）",
        "url": "https:\/\/api.douban.com\/v2\/book\/25708312",
        "alt_title": "C++ Primer, 5th Edition",
        "author_intro": "Stanley B. Lippman目前是微软公司 Visual C++ 团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne Stroustrup一起从事C++的设计与开发。他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。\nJosée Lajoie曾经是IBM加拿大研究中心C\/C++编译器开发团队的成员，在ISO C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。\nBarbara E. Moo是拥有25年软件经验的独立咨询顾问。在AT&T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。",
        "summary": "这本久负盛名的 C++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C++ 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《C++ Primer 中文版(第5版)》所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。",
        "price": "CNY 128.00"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 686,
          "average": "8.3",
          "min": 0
        },
        "subtitle": "标准C++导引",
        "author": [
          "[美] Bruce Eckel"
        ],
        "pubdate": "2002-9",
        "tags": [
          {
            "count": 416,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 152,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 127,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 94,
            "name": "编程思想",
            "title": "编程思想"
          },
          {
            "count": 85,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 73,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 64,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 33,
            "name": "程序开发",
            "title": "程序开发"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s1085408.jpg",
        "binding": "平装",
        "translator": [
          "刘宗田",
          "袁兆山",
          "潘秋菱"
        ],
        "catalog": "第一章  对象导言\n第二章  对象的创建于使用\n第三章  C++中的C\n第四章  数据抽象\n第五章  隐藏实现\n第六章  初始化与清除\n第七章  函数重载于默认参数\n第八章  常量\n第九章  内联函数\n第十章  名字控制\n……",
        "pages": "479",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s1085408.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s1085408.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s1085408.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1101524\/",
        "id": "1101524",
        "publisher": "机械工业出版社",
        "isbn10": "7111108078",
        "isbn13": "9787111108078",
        "title": "C++编程思想（第1卷）",
        "url": "https:\/\/api.douban.com\/v2\/book\/1101524",
        "alt_title": "Thinking in C++ Second Edition Volume One:Introduction to Standard C++ ",
        "author_intro": "Bruce Eckel是《Java编程思想》的作者，他有20年专业编程经验，并自1986年起教育人们如何撰写面向对象程序，足迹遍及全球，成为一位知名的C++教师和顾问，如今兼涉Java。Eckel是C++标准委员会拥有表决权的成员之一，曾经写过另五本面向对象编程书籍，发表过150篇以上的文章，是多本计算机杂志的专栏作家。Eckel开创Software Development Conference的C++、Java、Python等多项研讨活动。拥有应用物理学学士和计算机工程学硕士学位。",
        "summary": "《C++编程思考》第2版与第1版相比，在章节安排上有以下改变。增加了两章：“对象的创建与使用”和“C++中的C”，前者与“对象导言”实际上是第1版“对象的演化”一章的彻底重写，增加了近几年面向对象方法和编程方法的最瓣研究与实践的有效成果，后者的添加使不熟悉C的读者可以直接使用这本书。删去了四章：“输入输出流介绍”、“多重继承”、“异常处理”和“运行时类型识别”，删去的内容属于C++中较复杂的主题，作者将它们连同C++标准完成后又增加的一些内容放到第2卷中，使得第1卷的内容更加集中，供不同程度的读者选择阅读。需要强调的是，第2版的改变不仅体现在这些章节的调整上，更多的改变体现在每一章的字里行间中，包括例子的调整和练习的补充。与众不同的精心选材和认真推敲的叙述使得第2版更趋成熟。\n这本书是C++领域的一本权威著作，书中的内容、讲授方法、选用例子和跟随练习既适合课堂教学，又适合读者自学。",
        "series": {
          "id": "1163",
          "title": "计算机科学丛书"
        },
        "price": "59.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 456,
          "average": "8.1",
          "min": 0
        },
        "subtitle": "—C++\/C语言",
        "author": [
          "林锐",
          "韩永泉"
        ],
        "pubdate": "2007-5",
        "tags": [
          {
            "count": 216,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 152,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 124,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 102,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 78,
            "name": "高质量程序设计指南--C++\/c语言",
            "title": "高质量程序设计指南--C++\/c语言"
          },
          {
            "count": 69,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 68,
            "name": "编程风格",
            "title": "编程风格"
          },
          {
            "count": 63,
            "name": "C",
            "title": "C"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg",
        "binding": "",
        "translator": [],
        "catalog": "第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397",
        "pages": "394",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/2116929\/",
        "id": "2116929",
        "publisher": "电子工业",
        "isbn10": "7121041146",
        "isbn13": "9787121041143",
        "title": "高质量程序设计指南",
        "url": "https:\/\/api.douban.com\/v2\/book\/2116929",
        "alt_title": "",
        "author_intro": "林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。",
        "summary": "《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。",
        "price": "39.80元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 4212,
          "average": "9.2",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Stanley B.Lippman",
          "Josée LaJoie",
          "Barbara E.Moo"
        ],
        "pubdate": "2006",
        "tags": [
          {
            "count": 3383,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 1475,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 998,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 808,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 627,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 553,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 474,
            "name": "经典教材",
            "title": "经典教材"
          },
          {
            "count": 456,
            "name": "经典之作",
            "title": "经典之作"
          }
        ],
        "origin_title": "C++ Primer, 4th Edition",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1638975.jpg",
        "binding": "16开",
        "translator": [
          "李师贤",
          "蒋爱军",
          "梅晓勇",
          "林瑛"
        ],
        "catalog": "第1章 快速入门\n1.1 编写简单的C++程序\n1.2 初窥输入\/输出\n1.3 关于注释\n1.4 控制结构 入\n1.5 类的简介\n1.6 C++程序\n小结\n术语\n第一部分 基本语言\n第2章 变量和基本类型\n2.1 基本内置类型\n2.2 字面值常量\n2.3 变量\n2.4 const限定符\n2.5 引用\n2.6 typedef名字\n2.7 枚举\n2.8 类类型\n2.9 编写自己的头文件\n小结\n术语\n第3章 标准库类型\n3.1 命名空间的using声明\n3.2 标准库string类型\n3.3 标准库vector类型\n3.4 迭代器简介\n3.5 标准库bitset类型\n小结\n术语\n第4章 数组和指针\n4.1 数组\n4.2 指针的引入\n4.3 C风格字符串\n4.4 多维数组\n小结\n术语\n第5章 表达式\n5.1 算术操作符\n5.2 关系操作符和逻辑操作符\n5.3 位操作符\n5.4 赋值操作符\n5.5 自增和自减操作符\n5.6 箭头操作符\n5.7 条件操作符\n5.8 sizeof操作符\n5.9 逗号操作符\n5.10 复合表达式的求值\n5.11 new和delete表达式\n5.12 类型转换\n小结\n术语\n第6章 语句\n6.1 简单语句\n6.2 声明语句\n6.3 复合语句（块）\n6.4 语句作用域\n6.5 if语句\n6.6 switch语句\n6.7 while语句\n6.8 for循环语句\n6.9 do while语句\n6.10 break语句\n6.11 continue语句\n6.12 goto语句\n6.13 try块和异常处理\n6.14 使用预处理器进行调试\n小结\n术语\n第7章 函数\n7.1 函数的定义\n7.2 参数传递\n7.3 return语句\n7.4 函数声明\n7.5 局部对象\n7.6 内联函数\n7.7 类的成员函数\n7.8 重载函数\n7.9 指向函数的指针\n小结\n术语\n第8章 标准IO库\n8.1 面向对象的标准库\n8.2 条件状态\n8.3 输出缓冲区的管理\n8.4 文件的输入和输出\n8.5 字符串流\n小结\n术语\n第二部分 容器和算法\n第9章 顺序容器\n第10章 关联容器\n第11章 泛型算法\n第三部分 类和数据抽象\n第12章 类\n第13章 复制控制\n第14章 重载操作符与转换\n第四部分 面向对象编程与泛型编程\n第15章 面向对象编程\n第16章 模板与泛型编程\n第五部分 高级主题\n第17章 用于大型程序的工具\n第18章 特殊工具与技术\n附录 标准库\n索引",
        "pages": "745",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1638975.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1638975.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1638975.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1767741\/",
        "id": "1767741",
        "publisher": "人民邮电出版社",
        "isbn10": "7115145547",
        "isbn13": "9787115145543",
        "title": "C++ Primer 中文版（第 4 版）",
        "url": "https:\/\/api.douban.com\/v2\/book\/1767741",
        "alt_title": "C++ Primer, 4th Edition",
        "author_intro": "本书所有作者都是著名的C++权威人物。\nStanley B. Lippman目前是微软公司 Visual C++ 团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne Stroustrup一起从事C++的设计与开发。他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。他还著有Inside the C++ Object Model。\nJosée Lajoie曾经是IBM加拿大研究中心C\/C++编译器开发团队的成员，在ISO C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。\nBarbara E. Moo是拥有25年软件经验的独立咨询顾问。在AT&T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。她和Andrew Koenig合著了Accelerated C++和Ruminations on C++。",
        "summary": "本书是久负盛名的C++经典教程，其内容是C++大师Stanley B. Lippman丰富的实践经验和C++标准委员会原负责人Josée Lajoie对C++标准深入理解的完美结合，已经帮助全球无数程序员学会了C++。本版对前一版进行了彻底的修订，内容经过了重新组织，更加入了C++ 先驱Barbara E. Moo在C++教学方面的真知灼见。既显著改善了可读性，又充分体现了C++语言的最新进展和当前的业界最佳实践。书中不但新增大量教学辅助内容，用于强调重要的知识点，提醒常见的错误，推荐优秀的编程实践，给出使用提示，还包含大量来自实战的示例和习题。对C++基本概念和技术全面而且权威的阐述，对现代C++编程风格的强调，使本书成为C++初学者的最佳指南；对于中高级程序员，本书也是不可或缺的参考书。本书的前言阐述了 第4版和前一版的不同之处。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "99.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 190,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "C++ 11新特性解析与应用",
        "author": [
          "Michael Wong",
          "IBM XL编译器中国开发团队"
        ],
        "pubdate": "2013-6",
        "tags": [
          {
            "count": 146,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 133,
            "name": "C++11",
            "title": "C++11"
          },
          {
            "count": 47,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 47,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 36,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 27,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 23,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 21,
            "name": "新标准",
            "title": "新标准"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26689304.jpg",
        "binding": "",
        "translator": [],
        "catalog": "免责声明\n序\n前言\n第1章　新标准的诞生\n1.1　曙光：c++11标准的诞生\n1.1.1　c++11\/c++0x（以及c11\/c1x）—新标准诞生\n1.1.2　什么是c++11\/c++0x\n1.1.3　新c++语言的设计目标\n1.2　今时今日的c++\n1.2.1　c++的江湖地位\n1.2.2　c++11语言变化的领域\n1.3　c++11特性的分类\n1.4　c++特性一览\n1.4.1　稳定性与兼容性之间的抉择\n1.4.2　更倾向于使用库而不是扩展语言来实现特性\n1.4.3　更倾向于通用的而不是特殊的手段来实现特性\n1.4.4　专家新手一概支持\n1.4.5　增强类型的安全性\n1.4.6　与硬件紧密合作\n1.4.7　开发能够改变人们思维方式的特性\n1.4.8　融入编程现实\n1.5　本书的约定\n1.5.1　关于一些术语的翻译\n1.5.2　关于代码中的注释\n1.5.3　关于本书中的代码示例与实验平台\n第2章　保证稳定性和兼容性\n2.1　保持与c99兼容\n2.1.1　预定义宏\n2.1.2　__func__预定义标识符\n2.1.3　_pragma操作符\n2.1.4　变长参数的宏定义以及__va_args__\n2.1.5　宽窄字符串的连接\n2.2　long long整型\n2.3　扩展的整型\n2.4　宏__cplusplus\n2.5　静态断言\n2.5.1　断言：运行时与预处理时\n2.5.2　静态断言与static_assert\n2.6　noexcept修饰符与noexcept操作符\n2.7　快速初始化成员变量\n2.8　非静态成员的sizeof\n2.9　扩展的friend语法\n2.10　final\/override控制\n2.11　模板函数的默认模板参数\n2.12　外部模板\n2.12.1　为什么需要外部模板\n2.12.2　显式的实例化与外部模板的声明\n2.13　局部和匿名类型作模板实参\n2.14　本章小结\n第3章　通用为本，专用为末\n3.1　继承构造函数\n3.2　委派构造函数\n3.3　右值引用：移动语义和完美转发\n3.3.1　指针成员与拷贝构造\n3.3.2　移动语义\n3.3.3　左值、右值与右值引用\n3.3.4　std::move：强制转化为右值\n3.3.5　移动语义的一些其他问题\n3.3.6　完美转发\n3.4　显式转换操作符\n3.5　列表初始化\n3.5.1　初始化列表\n3.5.2　防止类型收窄\n3.6　pod类型\n3.7　非受限联合体\n3.8　用户自定义字面量\n3.9　内联名字空间\n3.10　模板的别名\n3.11　一般化的sfinea规则\n3.12　本章小结\n第4章　新手易学，老兵易用\n4.1　右尖括号>的改进\n4.2　auto类型推导\n4.2.1　静态类型、动态类型与类型推导\n4.2.2　auto的优势\n4.2.3　auto的使用细则\n4.3　decltype\n4.3.1　typeid与decltype\n4.3.2　decltype的应用\n4.3.3　decltype推导四规则\n4.3.4　cv限制符的继承与冗余的符号\n4.4　追踪返回类型\n4.4.1　追踪返回类型的引入\n4.4.2　使用追踪返回类型的函数\n4.5　基于范围的for循环\n4.6　本章小结\n第5章　提高类型安全\n5.1　强类型枚举\n5.1.1　枚举：分门别类与数值的名字\n5.1.2　有缺陷的枚举类型\n5.1.3　强类型枚举以及c++11对原有枚举类型的扩展\n5.2　堆内存管理：智能指针与垃圾回收\n5.2.1　显式内存管理\n5.2.2　c++11的智能指针\n5.2.3　垃圾回收的分类\n5.2.4　c++与垃圾回收\n5.2.5　c++11与最小垃圾回收支持\n5.2.6　垃圾回收的兼容性\n5.3　本章小结\n第6章　提高性能及操作硬件的能力\n6.1　常量表达式\n6.1.1　运行时常量性与编译时常量性\n6.1.2　常量表达式函数\n6.1.3　常量表达式值\n6.1.4　常量表达式的其他应用\n6.2　变长模板\n6.2.1　变长函数和变长的模板参数\n6.2.2　变长模板：模板参数包和函数参数包\n6.2.3　变长模板：进阶\n6.3　原子类型与原子操作\n6.3.1　并行编程、多线程与c++11\n6.3.2　原子操作与c++11原子类型\n6.3.3　内存模型，顺序一致性与memory_order\n6.4　线程局部存储\n6.5　快速退出：quick_exit与at_quick_exit\n6.6　本章小结\n第7章　为改变思考方式而改变\n7.1　指针空值—nullptr\n7.1.1　指针空值：从0到null，再到nullptr\n7.1.2　nullptr和nullptr_t\n7.1.3　一些关于nullptr规则的讨论\n7.2　默认函数的控制\n7.2.1　类与默认函数\n7.2.2　“= default”与“= deleted”\n7.3　lambda函数\n7.3.1　lambda的一些历史\n7.3.2　c++11中的lambda函数\n7.3.3　lambda与仿函数\n7.3.4　lambda的基础使用\n7.3.5　关于lambda的一些问题及有趣的实验\n7.3.6　lambda与stl\n7.3.7　更多的一些关于lambda的讨论\n7.4　本章小结\n第8章　融入实际应用\n8.1　对齐支持\n8.1.1　数据对齐\n8.1.2　c++11的alignof和alignas\n8.2　通用属性\n8.2.1　语言扩展到通用属性\n8.2.2　c++11的通用属性\n8.2.3　预定义的通用属性\n8.3　unicode支持\n8.3.1　字符集、编码和unicode\n8.3.2　c++11中的unicode支持\n8.3.3　关于unicode的库支持\n8.4　原生字符串字面量\n8.5　本章小结\n附录a　c++11对其他标准的不兼容项目\n附录b　弃用的特性\n附录c　编译器支持\n附录d　相关资源",
        "ebook_url": "https:\/\/read.douban.com\/ebook\/15245877\/",
        "pages": "328",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s26689304.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s26689304.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26689304.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/24738301\/",
        "id": "24738301",
        "publisher": "机械工业出版社",
        "isbn10": "7111426606",
        "isbn13": "9787111426608",
        "title": "深入理解C++11",
        "url": "https:\/\/api.douban.com\/v2\/book\/24738301",
        "alt_title": "",
        "author_intro": "",
        "summary": "《深入理解C++11:C++11新特性解析与应用》内容简介：国内首本全面深入解读C++11新标准的专著，由C++标准委员会代表和IBM XL编译器中国开发团队共同撰写。不仅详细阐述了C++11标准的设计原则，而且系统地讲解了C++11新标准中的所有新语言特性、新标准库特性、对原有特性的改进，以及如何应用所有这些新特性。\n《深入理解C++11:C++11新特性解析与应用》一共8章：第1章从设计思维和应用范畴两个维度对C++11新标准中的所有特性进行了分类，呈现了C++11新特性的原貌；第2章讲解了在保证与C语言和旧版C++标准充分兼容的原则下增加的一些新特性；第3章讲解了具有广泛可用性、能与其他已有的或者新增的特性结合起来使用的、具有普适性的一些新特性；第4章讲解了C++11新标准对原有一些语言特性的改进，这些特性不仅能让C++变得更强大，还能提升程序员编写代码的效率；第5章讲解了C++11在安全方面所做的改进，主要涵盖枚举类型安全和指针安全两个方面的内容；第6章讲解了为了进一步提升和挖掘C++程序性能和让C++能更好地适应各种新硬件的发展而设计的新特性，如多核、多线程、并行编程方面的新特性；第7章讲解了一些颠覆C++一贯设计思想的新特性，如lambda表达式等；第8章讲解了C++11为了解决C++编程中各种典型实际问题而做出的有效改进，如对Unicode的深入支持等。附录中则介绍了C++11标准与其他相关标准的兼容性和区别、C++11中弃用的特性、编译器对C++11的支持情况，以及学习C++11的相关资源。",
        "ebook_price": "25.00",
        "series": {
          "id": "43708",
          "title": "华章原创精品"
        },
        "price": "69.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 191,
          "average": "7.1",
          "min": 0
        },
        "subtitle": "C++面向对象程序设计",
        "author": [
          "谭浩强"
        ],
        "pubdate": "2006-1",
        "tags": [
          {
            "count": 89,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 49,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 40,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 35,
            "name": "C++面向对象程序设计",
            "title": "C++面向对象程序设计"
          },
          {
            "count": 31,
            "name": "教材",
            "title": "教材"
          },
          {
            "count": 24,
            "name": "谭浩强",
            "title": "谭浩强"
          },
          {
            "count": 10,
            "name": "課本",
            "title": "課本"
          },
          {
            "count": 10,
            "name": "中国",
            "title": "中国"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26009071.jpg",
        "binding": "简裝本",
        "translator": [],
        "catalog": "",
        "pages": "288",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s26009071.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s26009071.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26009071.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1731572\/",
        "id": "1731572",
        "publisher": "清华大学出版社",
        "isbn10": "7302123152",
        "isbn13": "9787302123156",
        "title": "C++面向对象程序设计",
        "url": "https:\/\/api.douban.com\/v2\/book\/1731572",
        "alt_title": "",
        "author_intro": "",
        "summary": "《普通高等教育\"十一五\"国家级规划教材•中国高等院校计算机基础教育课程体系规划教材:C++面向对象程序设计》作者谭浩强深入调查了我国大学的程序设计课程的现状和发展趋势，参阅了国内外数十种C++的教材，认真分析了学习者在学习过程中遇到的困难，研究了初学者的认识规律，做到准确定位，合理取舍内容，设计了读者易于学习的教材体系，并且以通俗易懂的语言化解了许多复杂的概念，大大减少了初学者学习C++的困难。",
        "series": {
          "id": "17060",
          "title": "中国高等教育计算机基础教育课程体系规划教材"
        },
        "price": "26.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1718,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "（第五版）",
        "author": [
          "Stephen Prata",
          "云巅工作室"
        ],
        "pubdate": "2005-2-1",
        "tags": [
          {
            "count": 891,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 830,
            "name": "c",
            "title": "c"
          },
          {
            "count": 809,
            "name": "c语言",
            "title": "c语言"
          },
          {
            "count": 596,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 467,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 378,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 370,
            "name": "C",
            "title": "C"
          },
          {
            "count": 240,
            "name": "programming",
            "title": "programming"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg",
        "binding": "平装(无盘)",
        "translator": [
          "云巅工作室"
        ],
        "catalog": "第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料",
        "pages": "626",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1240002\/",
        "id": "1240002",
        "publisher": "人民邮电出版社",
        "isbn10": "7115130221",
        "isbn13": "9787115130228",
        "title": "C Primer Plus",
        "url": "https:\/\/api.douban.com\/v2\/book\/1240002",
        "alt_title": "",
        "author_intro": "普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。",
        "summary": "《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。",
        "price": "60.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 19,
          "average": "8.5",
          "min": 0
        },
        "subtitle": "42招独家技巧助您改善C++11和C++14的高效用法",
        "author": [
          "Scott Meyers"
        ],
        "pubdate": "2018-4-23",
        "tags": [
          {
            "count": 60,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 27,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 19,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 14,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 8,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 7,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 7,
            "name": "C++11",
            "title": "C++11"
          },
          {
            "count": 5,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "Effective Modern C++",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29744649.jpg",
        "binding": "平装",
        "translator": [
          "高博"
        ],
        "catalog": "推荐序\n译者序\n对本书的称许\n出版商声明\n致谢\n绪论\n术语和惯例\n提交缺陷报告和改进建议\n型别推导\n条款1：理解模板型别推导\n条款2：理解auto型别推导\n条款3：理解decltype\n条款4：掌握查看型别推导结果的方法\nauto\n条款5：优先选用auto，而非显式型别声明\n条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法\n转向现代C++\n条款7：在创建对象时注意区分()和{}\n条款8：优先选用nullptr，而非0或NULL\n条款9：优先选用别名声明，而非typedef\n条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别\n条款11：优先选用删除函数，而非private未定义函数\n条款12：为意在改写的函数添加override声明\n条款13：优先选用const_iterator，而非iterator\n条款14：只要函数不会发射异常，就为其加上noexcept声明\n条款15：只要有可能使用constexpr，就使用它\n条款16：保证const成员函数的线程安全性\n条款17：理解特种成员函数的生成机制\n智能指针\n条款18：使用std::unique_ptr管理具备专属所有权的资源\n条款19：使用std::shared_ptr管理具备共享所有权的资源\n条款20：对于类似于std::shared_ptr、但有可能空悬的指针使用std::weak_ptr\n条款21：优先选用std::make_unique和std::make_shared，而非直接使用new\n条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中\n右值引用、移动语义和完美转发\n条款23：理解std::move和std::forward\n条款24：区分万能引用和右值引用\n条款25：针对右值引用实施std::move，针对万能引用实施std::forward\n条款26：避免依万能引用型别进行重载\n条款27：熟悉依万能引用型别进行重载的替代方案\n条款28：理解引用折叠\n条款29：假定移动操作不存在、成本高、未使用\n条款30：熟悉完美转发的失败情形\nlambda表达式\n条款31：避免默认捕获模式\n条款32：使用初始化捕获将对象移入闭包\n条款33：对auto&&型别的形参使用decltype，以std::forward之\n条款34：优先选用lambda式，而非std::bind\n并发API\n条款35：优先选用基于任务而非基于线程的程序设计\n条款36：如果异步是必要的，则指定std::launch::async\n条款37：使std::thread型别对象在所有路径皆不可联结\n条款38：对变化多端的线程句柄析构函数行为保持关注\n条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值\n条款40：对并发使用std::atomic，对特种内存使用volatile\n微调\n条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递\n条款42：考虑置入而非插入\n作者简介\n题记",
        "pages": "290",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s29744649.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s29744649.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29744649.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/30178902\/",
        "id": "30178902",
        "publisher": "中国电力出版社",
        "isbn10": "7519817741",
        "isbn13": "9787519817749",
        "title": "Effective Modern C++ 简体中文版",
        "url": "https:\/\/api.douban.com\/v2\/book\/30178902",
        "alt_title": "Effective Modern C++",
        "author_intro": "20多年来，Scott Meyers的“Effective C++从书”（包括《Effective C++》、《More Effecitve C++》和《Effective STL》）已经为C++程序设计指南的业界设立标杆。他清晰明了引人入胜的、对复杂技术材料进行条分缕析的阐释为他赢得了世界范围内的称誉，也使他成为一名广受欢迎的培训师、咨询顾问和会议讲师。他拥有布朗大学计算机科学专业的博士学位。",
        "summary": "想要彻底理解C++11和C++14，不可止步于熟悉它们引入的语言特性（例如，auto型别推导、移动语义、lambda表达式以及并发支持）。挑战在于高效地运用这些特性——从而使你的软件具备正确性、高效率、可维护性和可移植性。这正是这本实用的图书意欲达成的定位。它描述的正是使用C++11和C++14——现代C++来撰写真正卓越的软件之道。\n涵盖以下主题：\n大括号初始化、noexcept规格、完美转发，以及智能指针的make函数的优缺点\nstd::move、std::forward、右值引用和万能引用之间的联系\n撰写整洁、正确以及高效的lambda表达式的方法\nstd::atomic和volatile有怎样的区别，它们分别用于什么场合，以及它们和C++的并发API有何联系\n“旧”C++程序设计（即C++98）中的最佳实践要求在现代C++的软件开发中作出哪些修订\n《Effective Modern C++》沿用了Scott Meyers早期作品中业已证明的基于指导原则和实例驱动的格式，但介绍的是全新材料。本书是所有C++软件开发工程师的必读之选。",
        "price": "99"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 230,
          "average": "9.0",
          "min": 0
        },
        "subtitle": "Introduction to Standard C++, Volume One",
        "author": [
          "Bruce Eckel"
        ],
        "pubdate": "2000-3-25",
        "tags": [
          {
            "count": 263,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 75,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 68,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 63,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 49,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 47,
            "name": "c\/c++",
            "title": "c\/c++"
          },
          {
            "count": 29,
            "name": "Bruce.Eckel",
            "title": "Bruce.Eckel"
          },
          {
            "count": 20,
            "name": "经典",
            "title": "经典"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s2402561.jpg",
        "binding": "Paperback",
        "translator": [],
        "catalog": "",
        "pages": "814",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s2402561.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s2402561.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s2402561.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1459728\/",
        "id": "1459728",
        "publisher": "Prentice Hall",
        "isbn10": "0139798099",
        "isbn13": "9780139798092",
        "title": "Thinking in C++",
        "url": "https:\/\/api.douban.com\/v2\/book\/1459728",
        "alt_title": "",
        "author_intro": "",
        "summary": "In the first edition of Thinking in C++, Bruce Eckel synthesized years of C++ teaching and programming experience into a beautifully structured course in making the most of the language. It became an instant classic, winning the 1995 Software Development Jolt Cola Award for best book of the year. Now, Eckel has thoroughly rewritten Thinking in C++ to reflect the final ANSI\/ISO C++ standard. Every page has been revisited and rethought, with many new examples and exercises -- all designed to help you understand C++ \"down to the bare metal,\" so you can solve virtually any problem. Eckel starts with a detailed look at objects, showing how C++ programs can be constructed from off-the-shelf object libraries. This edition includes a new, chapter-length overview of the C features that are used in C++ -- plus a new CD-ROM containing an outstanding C seminar that covers all the foundations developers need before they can truly take advantage of C++. Eckel then walks through initialization and cleanup; function overloading and default arguments; constants; inline functions; name control; references and the copy constructor; operator overloading; and more. There are chapters on dynamic object creation; inheritance and composition; polymorphism and virtual functions, and templates. (Bonus coverage of string, templates, and the Standard Template Library, can be found at Eckel's web site.) Every chapter contains many modular, to-the-point examples, plus exercises based on Eckel's extensive experience teaching C++ seminars. Put simply, Eckel has made an outstanding book on C++ even better.",
        "price": "USD 73.00"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1095,
          "average": "9.5",
          "min": 0
        },
        "subtitle": "改善程序与设计的55个具体做法",
        "author": [
          "[美]Scott Meyers"
        ],
        "pubdate": "2006-7",
        "tags": [
          {
            "count": 695,
            "name": "c++",
            "title": "c++"
          },
          {
            "count": 389,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 323,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 303,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 240,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 200,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 178,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 143,
            "name": "Effective",
            "title": "Effective"
          }
        ],
        "origin_title": "Effective C++: 55 Specific Ways to Improve Your Programs and Designs",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1764864.jpg",
        "binding": "简裝本",
        "translator": [
          "侯捷"
        ],
        "catalog": "",
        "pages": "297",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1764864.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1764864.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1764864.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1842426\/",
        "id": "1842426",
        "publisher": "电子工业出版社",
        "isbn10": "712102909X",
        "isbn13": "9787121029097",
        "title": "Effective C++",
        "url": "https:\/\/api.douban.com\/v2\/book\/1842426",
        "alt_title": "Effective C++: 55 Specific Ways to Improve Your Programs and Designs",
        "author_intro": "Scott Meyers是全世界最知名的C++软件开发专家之一。他是畅销书《Effective C++》系列（Effective C++,More Effective C++,Effective STL）的作者，又是创新产品《Effective C++ CD》的设计者和作者，也是Addison-Wesley的“Effective Software Development Series\"顾问编辑，以及《Software Development》杂志咨询板成员。他也为若干新公司的技术咨询板提供服务。Meyers于1993年自Brown大学获得计算机博士学位。他的网址是www,aristeia.com.",
        "summary": "《Effective C++：改善程序与设计的55个具体做法》(中文版)(第3版)一共组织55个准则，每一条准则描述一个编写出更好的C++的方式。每一个条款的背后都有具体范例支撑。第三版有一半以上的篇幅是崭新内容，包括讨论资源管理和模板（templates）运用的两个新章。为反映出现代设计考虑，对第二版论题做了广泛的修订，包括异常（exceptions）、设计模式（design patterns）和多线程（multithreading）。\n《Effective C++》的重要特征包括：\n·高效的 classes、functions、templates 和inheritance hierarchies（继承体系）方面的专家级指导。\n·崭新的 TR1 标准程序库功能应用，以及与既有标准程序库组件的比较。\n·洞察 C++和其他语言（例如Java、C#、C）之间的不同。此举有助于那些来自其他语言阵营的开发人员消化吸收 C++ 式的各种解法。",
        "price": "58.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 352,
          "average": "9.3",
          "min": 0
        },
        "subtitle": "第六版",
        "author": [
          "普拉达 (Stephen Prata)"
        ],
        "pubdate": "2016-4-1",
        "tags": [
          {
            "count": 224,
            "name": "C语言",
            "title": "C语言"
          },
          {
            "count": 150,
            "name": "C",
            "title": "C"
          },
          {
            "count": 143,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 105,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 76,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 66,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 45,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 38,
            "name": "C++",
            "title": "C++"
          }
        ],
        "origin_title": "C Primer Plus : 6th",
        "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg",
        "binding": "平装",
        "translator": [
          "姜佑"
        ],
        "catalog": "第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726",
        "pages": "730",
        "images": {
          "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg",
          "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg",
          "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/26792521\/",
        "id": "26792521",
        "publisher": "人民邮电出版社",
        "isbn10": "7115390592",
        "isbn13": "9787115390592",
        "title": "C Primer Plus（第6版）中文版",
        "url": "https:\/\/api.douban.com\/v2\/book\/26792521",
        "alt_title": "C Primer Plus : 6th",
        "author_intro": "Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。",
        "summary": "《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。",
        "price": "CNY 89.00"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1403,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Stanley B. Lippman"
        ],
        "pubdate": "2001-5",
        "tags": [
          {
            "count": 1361,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 452,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 329,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 321,
            "name": "C\/C++",
            "title": "C\/C++"
          },
          {
            "count": 231,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 204,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 157,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 134,
            "name": "对象",
            "title": "对象"
          }
        ],
        "origin_title": "Inside the C++ Object Model",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3301634.jpg",
        "binding": "平装",
        "translator": [
          "侯捷"
        ],
        "catalog": "本立道生\n目录\n前言\n第0章 导读（译者的话）\n第1章 关于对象\n第2章 构造函数语意学\n第3章 Data语意学\n第4章 Function语意学\n第5章 构造、解构、拷贝语意学\n第6章 执行期语意学\n第7章 站在对象模型的尖端",
        "pages": "320",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s3301634.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s3301634.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3301634.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/1091086\/",
        "id": "1091086",
        "publisher": "华中科技大学出版社",
        "isbn10": "7560924182",
        "isbn13": "9787560924182",
        "title": "深度探索C++对象模型",
        "url": "https:\/\/api.douban.com\/v2\/book\/1091086",
        "alt_title": "Inside the C++ Object Model",
        "author_intro": "Stanley B. Lippman的工作是提供关于C++和面向对象的训练、咨询、设计和指导。Lippman在成为一名独立咨询顾问之前，曾经是迪士尼动化公司的首席软件设计师。他在AT&T Bell实验室的时候，领导了cfront 3.0版本和2.1版本的编译器开发组。他也是Bjarne Stroustrup领导的Bell实验室Foundation项目的成员之一，负责C++程序设计环境中的对象模型部分。Lippman还撰写了许多关于C++的论文。目前Lippman已受雇于微软公司，负责Visual C++项目。\n译者侯捷：电脑技术自由作家，对于技术的钻研和发表，有独特的品性与坚持。作品涵盖著、译、评三方面，散见于各种刊特、媒体、网站论坛。",
        "summary": "这本书探索“对象导向程序所支持的C++对象模型”下的程序行为。对于“对象导向性质之基础实现技术”以及“各种性质背后的隐含利益交换”提供一个清楚的认识。检验由程序变形所带来的效率冲击。提供丰富的程序范例、图片，以及对象导向观念和底层对象模型之间的效率测量。",
        "price": "54.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 91,
          "average": "7.8",
          "min": 0
        },
        "subtitle": "A History Of Britain: At The Edge Of The World? 3500 B.C. - 1603 A.D.",
        "author": [
          "[英] 西蒙·沙玛"
        ],
        "pubdate": "2018-7",
        "tags": [
          {
            "count": 207,
            "name": "英国史",
            "title": "英国史"
          },
          {
            "count": 207,
            "name": "历史",
            "title": "历史"
          },
          {
            "count": 140,
            "name": "英国",
            "title": "英国"
          },
          {
            "count": 101,
            "name": "欧洲史",
            "title": "欧洲史"
          },
          {
            "count": 79,
            "name": "西蒙·沙玛",
            "title": "西蒙·沙玛"
          },
          {
            "count": 69,
            "name": "世界史",
            "title": "世界史"
          },
          {
            "count": 65,
            "name": "历史学",
            "title": "历史学"
          },
          {
            "count": 61,
            "name": "英国研究",
            "title": "英国研究"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29802351.jpg",
        "binding": "平装",
        "translator": [
          "彭灵"
        ],
        "catalog": "卷I  在世界的边缘？ 3000BC—AD1603\n序言\n第一章 在世界的边缘？\n第二章 征服\n第三章 王权无约束？\n第四章 外来者和本地人\n第五章 死亡之神\n第六章 燃烧的信念\n第七章 女王一身\n致谢\n参考文献\n卷II  不列颠的战争 1603—1776\n序言\n第一章 重塑不列颠\n第二章 帝王之业乎？\n第三章 寻找利维坦\n第四章 未竟事业\n第五章 不列颠股份公司\n第六章 谬误帝国\n致谢\n参考文献\n卷III  帝国的命运 1776—2000\n序言\n第一章 自然的力量：通往革命之路？\n第二章 自然的力量：回家之路\n第三章 女王与蜂巢\n第四章 妻子、女儿和寡妇\n第五章 “好心”帝国的投资\n第六章 “好心”帝国的红利\n第七章 最后的布莱兹欧弗\n第八章 忍 耐\n致 谢\n参考文献",
        "pages": "1520",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s29802351.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s29802351.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29802351.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/26877230\/",
        "id": "26877230",
        "publisher": "中信出版集团",
        "isbn10": "7508649303",
        "isbn13": "9787508649306",
        "title": "英国史（全三卷）",
        "url": "https:\/\/api.douban.com\/v2\/book\/26877230",
        "alt_title": "",
        "author_intro": "西蒙·沙玛（Simon Schama)，英国国家学术院院士、皇家文学学会会员。他1945年出生于伦敦，21岁在剑桥大学以优等生身份毕业，随后在剑桥大学和牛津大学教书。1977 年，他出版第一部专著《爱国者和解放者》，即获沃尔夫森历史奖。1980年，在哈佛大学谋得教席，后“转会”至哥伦比亚大学担任教授。在美国期间，他陆续出版了多本学术著作，获得了学界的极大关注和大批读者的认可。其中《财富的窘境》（1987）、《公民们》（1989）分别获得当年的《纽约时报书评》年度好书奖，《风景与记忆》（1995）获得W.H.史密斯文学奖。\n1995年，沙玛受邀将《风景与记忆》改编为系列电视片，充分展示了其叙事功底和画面意识。之后，BBC邀请沙玛编写并主持大型纪录片《英国史》。沙玛特地迁回英国，专心投身于《英国史》的创作。这部15集的电视片于2000年开播，赢得如潮好评，收视率和DVD销量都创下纪录。沙玛也以此片获得广播新闻协会作家奖。\n2001年，西蒙·沙玛获封大英帝国司令勋章（CBE）。2003年，他与BBC和哈珀柯林斯出版集团签订了一份金额高达300万英镑的合约，包含三本新书和伴生的两部纪录片。其中的第一本书《乱世交汇》获得了全美书评学会奖。他跟BBC等电视台合作的纪录片还包括《美国的未来》《艺术的力量》《犹太人的故事》《英国的面孔》等，均获得极高的评价，也引起了中国观众和读者的极大关注。\n2018年，西蒙·沙玛还参与了重量级九集纪录片《文明》的创作，编写和主持了其中的五集。",
        "summary": "沃尔夫森历史奖、W.H.史密斯文学奖得主西蒙·沙玛，以恢弘而凝练的笔调带你进入英国故事。从罗马入侵到诺曼征服，从黑死病到伊丽莎白的辉煌，从光荣革命到两次世界大战，英国历史上的战争与和平随着他的讲述，恍如重演。人物和场景在历史幻灯中跳跃。现代文明先驱者的艰险历程令人动容。\n全书共分三卷。\n《英国史Ⅰ: 在世界的边缘？ 3000BC—AD1603》包括超过1500年的英国历史，从罗马第一次入侵到伊丽莎白女王非凡的统治时期。本书的视角从文明诞生开始，到诺曼征服，从宗教战争、黑暗的中世纪到亨利二世的国家风波；黑死病的爆发，几乎毁了半个欧洲的人口，都铎王朝错综复杂的矛盾，伊丽莎白一世和苏格兰玛丽女王之间的冲突构成了本卷的主要内容。通过故事本身探索相互关联的主题网络——一个民族国家的形成究竟是因何形成，压迫者和被压迫者之间的斗争，历史内在推动的力量都在期间可见一斑。\n《英国史II: 不列颠的战争 1603—1776》是一部英国战争的历史：理想主义的枯萎，令人震惊的大屠杀，和意想不到的结果以及令人吃惊的生活。在这一卷中，西蒙•沙马唤起战争、饥荒、瘟疫的恐怖，火焰燃烧的城市，破碎家庭的悲情，父亲和儿子被迫选择对立。但他也抓住了宫殿和议会的亲密关系和利润和快乐的诱惑。在矛盾与冲突中，展示出英国贵族的众生相。这些冲突在爱尔兰和苏格兰之间，在国会与王室之间展开。打破“联合王国”的错觉，成千上万的为此丢掉了生命。比死于第一次世界大战更大的人口比例。当宗教激情让位给可以产生利润的消费热情，它有可能成将英国变成一个致力于成为“成功的企业”而凝聚在一起的不列颠集合体。在几代人的经营下，英国扩展极快，他在为成为世界上前所未有的强大的帝国积蓄能量。\n《英国史Ⅲ: 帝国的命运 1776—2000》从18世纪70年代讲起。一个人怎么能让自己的自由过多地区从与世界。 一个对自己军队不信任的国家，变成了军事强国。在野心、奴隶和勇敢地探险者的帮助下英国建立了一个强大帝国，将它的国旗插遍了全球。通过令人上瘾的茶叶、糖和咖啡贸易，它控制了殖民地。 英国从1789年法国革命中吸取了不少的经验。维多利亚女王18岁登基，统治一个令人疼痛但在工业革命中迅速发展的国家。 混乱和革命预示着革新，但事实上家庭生活习惯和传统依然是国家稳定的基石。 大英帝国承诺了和平、稳定和繁荣。但在爱尔兰和印度却如此相像的充斥着暴力和饥荒。 在书的最后，西蒙•沙玛陷入了对过去的英国20世纪的历史的沉思中。 探讨了英国在两次世界大战中命运和消沉、不安的战后和平。\n--------------------\n【编辑推荐】\n1.值得期待的英国新通史，新观点、新视角、新材料\n目前国内能见到的英国通史，大多是出版时间非常早的经典著作，本书是西蒙·沙玛以全新视角，配合BBC纪录片撰写的全新通史，运用了新的材料和很多BBC才能获得的特殊资源，提出了一些新看法。\n2.西蒙·沙玛，与霍布斯保姆和尼尔弗格森同量级的历史学家，沃尔夫森历史奖、W.H.史密斯文学奖、全美书评学会奖得主。\n学术著作曾获沃尔夫森历史奖、W.H.史密斯文学奖，与霍布斯保姆并称英国历史学界双雄。\n讲故事的行家、深受大众喜爱的电视明星。编写、主持过系列纪录片《英国史》、《艺术的力量》、《美国的未来》等，社会影响力只有尼尔·弗格森可与之匹敌。\n3．BBC出品，必属精品，破收视和DVD销售记录。本书比纪录片更丰富、更完整。\n英国高水准历史学家与BBC精良制作的结合，记录片的收视和DVD销售量都创记录。书在保持通俗性的基础上，将大量纪录片无法容纳的有趣材料和细节展现出来，同时更多的加入作者对时代状况和特征的分析和解读。\n4．英国是现代化的范本国家和先驱者，要了解现代化历程，当然要读英国史。\n一个传统国家究竟因为何种因素转变为现代国家，从商业到宗教、从制度到文化、从科技到环境，历史内在推动的力量到底何在？。英国作为现代化的范本国家和先驱者，其历史的可读性与启发性都足够说服我们去仔细研究。\n5. 涵盖英国历史上极富戏剧性的重大事件和争议人物，对世界文明进程有重大影响。\n事件：诺曼征服、玫瑰战争、苏格兰叛乱、光荣革命、议会制度和君主立宪的建立、工业革命、美国革命和大英帝国的兴起和衰落。\n人物：亨利八世和他的妻子们、莎士比亚、牛顿、达尔文、伊丽莎白女王、克伦威尔、丘吉尔。\n6. 既如小说般精彩跌宕，又有史诗般宏大视野和问题意识\n沙玛既有高超的讲故事能力，又有深厚的历史学术功底。使得本书具备通俗性和趣味性，将戏剧性非常强的英国历史还原得精彩纷呈；同时，又带着问题意识来梳理时代特征、剪裁史料、深入分析，也能为学术和严肃读者提供有启发性的观点和叙述。\n7. 近百幅珍贵历史图片，画面感十足。\n8. 甫一出版，就获得比纪录片更高的赞誉和评论。\n西蒙·沙玛的这三册《英国史》与纪录片相比更加的丰富与完整，跨度巨大且没有一丝赘语，这是一部生动到足以唤醒你的历史。                            ——《每日邮报》\n------------------\n【赞誉推荐】\n沙玛著作的优点是学识渊博、风格独特、雄辩滔滔\n——艾瑞克·霍布斯保姆\n西蒙·沙玛的这三册《英国史》与纪录片相比更加的丰富与完整，跨度巨大且没有一丝赘语，这是一部生动到足以唤醒你的历史。\n——《每日邮报》\n沙玛不太在意“英国”这概念是否真的存在过。他说有，然后我们就同意了。这就是为什么这是本好书。\n——《泰晤士报》\n战争与和平，二者之间的林林总总，精彩纷呈的呈现在西蒙·沙玛的《英国史》中。\n—— 《金融时报》\n非凡之作。任何概述都无法传达这本书丰富的内容。它会让人沉浸其中，给人滋养，令人着迷。\n——《纽约书评》\n他是那个讲故事的人，广泛深入阅读当代重构派历史，英国史的优良向导。\n—— 《纽约时报》\n西蒙·沙玛是天赋和成就都惊人的历史学家。\n——《旁观者》\n历史在他笔下恍如重演，动态跳跃与可读性兼具。\n——《星期日快报》\n沙玛有大师般的能力，将人物与冲突之间的关系用幻灯般的手法再现。\n——《金融时报》",
        "price": "238.00元"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 631,
          "average": "8.7",
          "min": 0
        },
        "subtitle": "一本37.5°C的博物馆地图",
        "author": [
          "沈辛成"
        ],
        "pubdate": "2017-5-20",
        "tags": [
          {
            "count": 522,
            "name": "纽约",
            "title": "纽约"
          },
          {
            "count": 501,
            "name": "博物馆",
            "title": "博物馆"
          },
          {
            "count": 417,
            "name": "旅行",
            "title": "旅行"
          },
          {
            "count": 335,
            "name": "美国",
            "title": "美国"
          },
          {
            "count": 295,
            "name": "艺术",
            "title": "艺术"
          },
          {
            "count": 243,
            "name": "城市",
            "title": "城市"
          },
          {
            "count": 185,
            "name": "历史",
            "title": "历史"
          },
          {
            "count": 165,
            "name": "生活",
            "title": "生活"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg",
        "binding": "精装",
        "translator": [],
        "catalog": "指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名",
        "pages": "380",
        "images": {
          "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg",
          "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg",
          "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"
        },
        "alt": "https:\/\/book.douban.com\/subject\/27037182\/",
        "id": "27037182",
        "publisher": "中西书局",
        "isbn10": "7547512488",
        "isbn13": "9787547512487",
        "title": "纽约无人是客",
        "url": "https:\/\/api.douban.com\/v2\/book\/27037182",
        "alt_title": "",
        "author_intro": "沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。",
        "summary": "本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。",
        "price": "39.80元"
      }
    ]
  }